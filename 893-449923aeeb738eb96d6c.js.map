{"version":3,"file":"893-449923aeeb738eb96d6c.js","mappings":"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","sources":["webpack://shakil-ahmmed/./node_modules/three/examples/jsm/geometries/TextGeometry.js","webpack://shakil-ahmmed/./node_modules/three/examples/jsm/loaders/FontLoader.js","webpack://shakil-ahmmed/./node_modules/three/examples/jsm/loaders/RGBELoader.js","webpack://shakil-ahmmed/./src/components/ThreeDS.tsx"],"sourcesContent":["/**\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  depth: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n *  bevelOffset: <float> // how far from text outline does bevel start\n * }\n */\n\nimport {\n\tExtrudeGeometry\n} from 'three';\n\nclass TextGeometry extends ExtrudeGeometry {\n\n\tconstructor( text, parameters = {} ) {\n\n\t\tconst font = parameters.font;\n\n\t\tif ( font === undefined ) {\n\n\t\t\tsuper(); // generate default extrude geometry\n\n\t\t} else {\n\n\t\t\tconst shapes = font.generateShapes( text, parameters.size );\n\n\t\t\t// translate parameters to ExtrudeGeometry API\n\n\t\t\tif ( parameters.depth === undefined && parameters.height !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.TextGeometry: .height is now depreciated. Please use .depth instead' ); // @deprecated, r163\n\n\t\t\t}\n\n\t\t\tparameters.depth = parameters.depth !== undefined ?\n\t\t\t\tparameters.depth : parameters.height !== undefined ?\n\t\t\t\t\tparameters.height : 50;\n\n\t\t\t// defaults\n\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\t\tsuper( shapes, parameters );\n\n\t\t}\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n}\n\n\nexport { TextGeometry };\n","import {\n\tFileLoader,\n\tLoader,\n\tShapePath\n} from 'three';\n\nclass FontLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tconst font = scope.parse( JSON.parse( text ) );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\treturn new Font( json );\n\n\t}\n\n}\n\n//\n\nclass Font {\n\n\tconstructor( data ) {\n\n\t\tthis.isFont = true;\n\n\t\tthis.type = 'Font';\n\n\t\tthis.data = data;\n\n\t}\n\n\tgenerateShapes( text, size = 100 ) {\n\n\t\tconst shapes = [];\n\t\tconst paths = createPaths( text, size, this.data );\n\n\t\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tshapes.push( ...paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nfunction createPaths( text, size, data ) {\n\n\tconst chars = Array.from( text );\n\tconst scale = size / data.resolution;\n\tconst line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tconst paths = [];\n\n\tlet offsetX = 0, offsetY = 0;\n\n\tfor ( let i = 0; i < chars.length; i ++ ) {\n\n\t\tconst char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tconst ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tconst glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) {\n\n\t\tconsole.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' );\n\n\t\treturn;\n\n\t}\n\n\tconst path = new ShapePath();\n\n\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tconst outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( let i = 0, l = outline.length; i < l; ) {\n\n\t\t\tconst action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\nexport { FontLoader, Font };\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","import React, { useEffect } from \"react\";\nimport * as THREE from \"three\";\n\nimport { TextGeometry } from \"three/examples/jsm/geometries/TextGeometry.js\";\nimport { Font, FontLoader } from \"three/examples/jsm/loaders/FontLoader.js\";\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader.js\";\n\nexport default function ThreeDS() {\n  useEffect(() => {\n    THREE.Cache.enabled = true;\n\n    let container: HTMLDivElement;\n\n    let camera: THREE.PerspectiveCamera;\n    let cameraTarget: THREE.Vector3;\n    let scene: THREE.Scene;\n    let renderer: THREE.WebGLRenderer;\n\n    let group: THREE.Group;\n    let textMesh1: THREE.Mesh;\n    let textMesh2: THREE.Mesh;\n    let textGeo: TextGeometry;\n    let materialMain: THREE.MeshPhysicalMaterial[];\n    let materialMirror: THREE.MeshPhysicalMaterial[];\n\n    const text: string = \"Shak!l\";\n    let font: Font;\n\n    const depth = 4,\n      size = 80,\n      curveSegments = 10,\n      bevelThickness = 10,\n      bevelSize = 2,\n      bevelSegments = 5;\n\n    const mirror = true;\n\n    let pointerY = 0;\n    let targetRotationY = 0;\n\n    let pointerX = 0;\n    let targetRotationX = 0;\n\n    let windowHalfX = window.innerWidth / 2;\n    let windowHalfY = window.innerHeight / 2;\n\n    init();\n\n    animate();\n\n    function init() {\n      const options = {\n        color: 0xffffff,\n        roughness: 0.6,\n        metalness: 1,\n        transmission: 0.8,\n        reflectivity: 0.75,\n        thickness: 1,\n        envMapIntensity: 5,\n        // clearcoat: 1,\n        // clearcoatRoughness: 0.1,\n        // normalScale: 0.3,\n        // clearcoatNormalScale: 0.2,\n      };\n\n      // const textureLoader = new THREE.TextureLoader();\n      // const normalMapTexture = textureLoader.load(\"/normal.jpg\");\n      // normalMapTexture.wrapS = THREE.RepeatWrapping;\n      // normalMapTexture.wrapT = THREE.RepeatWrapping;\n      // normalMapTexture.repeat.set(3, 3);\n\n      container = document.createElement(\"div\");\n      const threeCanvas = document.getElementById(\n        \"threeCanvas\"\n      ) as HTMLDivElement;\n      threeCanvas.appendChild(container);\n\n      camera = new THREE.PerspectiveCamera(\n        30,\n        window.innerWidth / window.innerHeight,\n        1,\n        1500\n      );\n      camera.position.set(0, 400, 700);\n\n      cameraTarget = new THREE.Vector3(0, 150, 90);\n\n      scene = new THREE.Scene();\n      scene.fog = new THREE.Fog(0x000000, 250, 1400);\n\n      const dirLight = new THREE.DirectionalLight(0xffffff, 8);\n      dirLight.position.set(1, 1, 1).normalize();\n      scene.add(dirLight);\n\n      const envMap = new RGBELoader().load(\"/env.hdr\", () => {\n        envMap.mapping = THREE.EquirectangularReflectionMapping;\n      });\n\n      materialMain = [\n        new THREE.MeshPhysicalMaterial({\n          ...options,\n          envMap,\n          // normalScale: new THREE.Vector2(options.normalScale),\n          // normalMap: normalMapTexture,\n          // clearcoatNormalMap: normalMapTexture,\n          // clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale),\n        }),\n        new THREE.MeshPhysicalMaterial({\n          ...options,\n          envMap,\n          // normalScale: new THREE.Vector2(options.normalScale),\n          // normalMap: normalMapTexture,\n          // clearcoatNormalMap: normalMapTexture,\n          // clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale),\n        }),\n      ];\n\n      materialMirror = [\n        new THREE.MeshPhysicalMaterial({\n          ...options,\n          color: 0x000000,\n          envMap,\n          // normalScale: new THREE.Vector2(0.3),\n          // normalMap: normalMapTexture,\n          // clearcoatNormalMap: normalMapTexture,\n          // clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale),\n        }),\n        new THREE.MeshPhysicalMaterial({\n          ...options,\n          color: 0x000000,\n          envMap,\n          // normalScale: new THREE.Vector2(0.3),\n          // normalMap: normalMapTexture,\n          // clearcoatNormalMap: normalMapTexture,\n          // clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale),\n        }),\n      ];\n\n      group = new THREE.Group();\n      group.position.y = 100;\n\n      scene.add(group);\n\n      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n      renderer.setClearColor(0x000000, 0);\n      renderer.setPixelRatio(window.devicePixelRatio);\n      renderer.setSize(window.innerWidth, window.innerHeight);\n\n      container.appendChild(renderer.domElement);\n      container.style.touchAction = \"none\";\n      document.body.addEventListener(\"pointermove\", onPointerMove);\n\n      window.addEventListener(\"resize\", onWindowResize);\n    }\n\n    function onWindowResize() {\n      windowHalfX = window.innerWidth / 2;\n      windowHalfY = window.innerHeight / 2;\n\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function loadFont() {\n      const loader = new FontLoader();\n      loader.load(\"/Thunder_Black.json\", function (response) {\n        font = response;\n\n        refreshText();\n      });\n    }\n    loadFont();\n\n    function createText() {\n      textGeo = new TextGeometry(text, {\n        font,\n        size,\n        depth,\n        curveSegments,\n        bevelThickness,\n        bevelSize,\n        bevelSegments,\n        bevelEnabled: true,\n      });\n\n      textGeo.computeBoundingBox();\n\n      if (!textGeo.boundingBox) return;\n      const centerOffset =\n        -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);\n\n      textMesh1 = new THREE.Mesh(textGeo, materialMain);\n\n      textMesh1.position.x = centerOffset;\n      textMesh1.position.y = 16;\n      textMesh1.position.z = 0;\n\n      textMesh1.rotation.x = 0;\n      textMesh1.rotation.y = Math.PI * 2;\n\n      group.add(textMesh1);\n\n      if (mirror) {\n        textMesh2 = new THREE.Mesh(textGeo, materialMirror);\n\n        textMesh2.position.x = centerOffset;\n        textMesh2.position.z = depth;\n\n        textMesh2.rotation.x = Math.PI;\n        textMesh2.rotation.y = Math.PI * 2;\n\n        textMesh2.scale.set(1, 1, 1);\n\n        group.add(textMesh2);\n      }\n    }\n\n    function refreshText() {\n      group.remove(textMesh1);\n      if (mirror) group.remove(textMesh2);\n\n      if (!text) return;\n\n      createText();\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      pointerX = event.clientX - windowHalfX;\n      pointerY = event.clientY - windowHalfY;\n\n      targetRotationY = pointerX * 0.001;\n      targetRotationX = pointerY * 0.001;\n    }\n\n    function animate() {\n      requestAnimationFrame(animate);\n      render();\n    }\n\n    function render() {\n      group.rotation.y += (targetRotationY - group.rotation.y) * 0.05;\n      group.rotation.x += (targetRotationX - group.rotation.x) * 0.05;\n      camera.lookAt(cameraTarget);\n      renderer.clear();\n      renderer.render(scene, camera);\n    }\n  }, []);\n  return <div id=\"threeCanvas\"></div>;\n}\n"],"names":["TextGeometry","constructor","text","parameters","font","undefined","super","shapes","generateShapes","size","depth","height","console","warn","bevelThickness","bevelSize","bevelEnabled","this","type","FontLoader","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","parse","JSON","json","Font","data","isFont","paths","chars","Array","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","length","char","ret","createPath","push","createPaths","p","pl","toShapes","glyph","glyphs","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","RGBELoader","buffer","rgbe_error","rgbe_error_code","msg","Error","fgets","lineLimit","consume","pos","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","Math","pow","RGBEByteToRGBHalf","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","line","match","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","set","off","RGBE_ReadPixels_RLE","numElements","floatArray","Float32Array","j","halfArray","setDataType","value","texture","texData","colorSpace","minFilter","magFilter","generateMipmaps","flipY","ThreeDS","useEffect","container","camera","cameraTarget","scene","renderer","group","textMesh1","textMesh2","textGeo","materialMain","materialMirror","THREE","enabled","curveSegments","bevelSegments","mirror","pointerY","targetRotationY","pointerX","targetRotationX","windowHalfX","window","innerWidth","windowHalfY","innerHeight","onWindowResize","aspect","updateProjectionMatrix","setSize","onPointerMove","event","clientX","clientY","options","color","roughness","metalness","transmission","reflectivity","thickness","envMapIntensity","document","createElement","getElementById","appendChild","position","fog","dirLight","normalize","add","envMap","mapping","antialias","alpha","setClearColor","setPixelRatio","devicePixelRatio","domElement","style","touchAction","body","addEventListener","init","animate","requestAnimationFrame","rotation","lookAt","clear","render","response","remove","computeBoundingBox","centerOffset","max","z","PI","createText","React","id"],"sourceRoot":""}